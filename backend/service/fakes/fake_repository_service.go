// Code generated by counterfeiter. DO NOT EDIT.
package fakes

import (
	"sync"

	"github.com/dpolansky/grader-ci/model"
)

type FakeRepositoryService struct {
	GetRepositoryByIDStub        func(id int) (*model.Repository, error)
	getRepositoryByIDMutex       sync.RWMutex
	getRepositoryByIDArgsForCall []struct {
		id int
	}
	getRepositoryByIDReturns struct {
		result1 *model.Repository
		result2 error
	}
	getRepositoryByIDReturnsOnCall map[int]struct {
		result1 *model.Repository
		result2 error
	}
	GetRepositoriesByOwnerStub        func(owner string) ([]*model.Repository, error)
	getRepositoriesByOwnerMutex       sync.RWMutex
	getRepositoriesByOwnerArgsForCall []struct {
		owner string
	}
	getRepositoriesByOwnerReturns struct {
		result1 []*model.Repository
		result2 error
	}
	getRepositoriesByOwnerReturnsOnCall map[int]struct {
		result1 []*model.Repository
		result2 error
	}
	GetRepositoriesStub        func() ([]*model.Repository, error)
	getRepositoriesMutex       sync.RWMutex
	getRepositoriesArgsForCall []struct{}
	getRepositoriesReturns     struct {
		result1 []*model.Repository
		result2 error
	}
	getRepositoriesReturnsOnCall map[int]struct {
		result1 []*model.Repository
		result2 error
	}
	UpdateRepositoryStub        func(m *model.Repository) error
	updateRepositoryMutex       sync.RWMutex
	updateRepositoryArgsForCall []struct {
		m *model.Repository
	}
	updateRepositoryReturns struct {
		result1 error
	}
	updateRepositoryReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeRepositoryService) GetRepositoryByID(id int) (*model.Repository, error) {
	fake.getRepositoryByIDMutex.Lock()
	ret, specificReturn := fake.getRepositoryByIDReturnsOnCall[len(fake.getRepositoryByIDArgsForCall)]
	fake.getRepositoryByIDArgsForCall = append(fake.getRepositoryByIDArgsForCall, struct {
		id int
	}{id})
	fake.recordInvocation("GetRepositoryByID", []interface{}{id})
	fake.getRepositoryByIDMutex.Unlock()
	if fake.GetRepositoryByIDStub != nil {
		return fake.GetRepositoryByIDStub(id)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.getRepositoryByIDReturns.result1, fake.getRepositoryByIDReturns.result2
}

func (fake *FakeRepositoryService) GetRepositoryByIDCallCount() int {
	fake.getRepositoryByIDMutex.RLock()
	defer fake.getRepositoryByIDMutex.RUnlock()
	return len(fake.getRepositoryByIDArgsForCall)
}

func (fake *FakeRepositoryService) GetRepositoryByIDArgsForCall(i int) int {
	fake.getRepositoryByIDMutex.RLock()
	defer fake.getRepositoryByIDMutex.RUnlock()
	return fake.getRepositoryByIDArgsForCall[i].id
}

func (fake *FakeRepositoryService) GetRepositoryByIDReturns(result1 *model.Repository, result2 error) {
	fake.GetRepositoryByIDStub = nil
	fake.getRepositoryByIDReturns = struct {
		result1 *model.Repository
		result2 error
	}{result1, result2}
}

func (fake *FakeRepositoryService) GetRepositoryByIDReturnsOnCall(i int, result1 *model.Repository, result2 error) {
	fake.GetRepositoryByIDStub = nil
	if fake.getRepositoryByIDReturnsOnCall == nil {
		fake.getRepositoryByIDReturnsOnCall = make(map[int]struct {
			result1 *model.Repository
			result2 error
		})
	}
	fake.getRepositoryByIDReturnsOnCall[i] = struct {
		result1 *model.Repository
		result2 error
	}{result1, result2}
}

func (fake *FakeRepositoryService) GetRepositoriesByOwner(owner string) ([]*model.Repository, error) {
	fake.getRepositoriesByOwnerMutex.Lock()
	ret, specificReturn := fake.getRepositoriesByOwnerReturnsOnCall[len(fake.getRepositoriesByOwnerArgsForCall)]
	fake.getRepositoriesByOwnerArgsForCall = append(fake.getRepositoriesByOwnerArgsForCall, struct {
		owner string
	}{owner})
	fake.recordInvocation("GetRepositoriesByOwner", []interface{}{owner})
	fake.getRepositoriesByOwnerMutex.Unlock()
	if fake.GetRepositoriesByOwnerStub != nil {
		return fake.GetRepositoriesByOwnerStub(owner)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.getRepositoriesByOwnerReturns.result1, fake.getRepositoriesByOwnerReturns.result2
}

func (fake *FakeRepositoryService) GetRepositoriesByOwnerCallCount() int {
	fake.getRepositoriesByOwnerMutex.RLock()
	defer fake.getRepositoriesByOwnerMutex.RUnlock()
	return len(fake.getRepositoriesByOwnerArgsForCall)
}

func (fake *FakeRepositoryService) GetRepositoriesByOwnerArgsForCall(i int) string {
	fake.getRepositoriesByOwnerMutex.RLock()
	defer fake.getRepositoriesByOwnerMutex.RUnlock()
	return fake.getRepositoriesByOwnerArgsForCall[i].owner
}

func (fake *FakeRepositoryService) GetRepositoriesByOwnerReturns(result1 []*model.Repository, result2 error) {
	fake.GetRepositoriesByOwnerStub = nil
	fake.getRepositoriesByOwnerReturns = struct {
		result1 []*model.Repository
		result2 error
	}{result1, result2}
}

func (fake *FakeRepositoryService) GetRepositoriesByOwnerReturnsOnCall(i int, result1 []*model.Repository, result2 error) {
	fake.GetRepositoriesByOwnerStub = nil
	if fake.getRepositoriesByOwnerReturnsOnCall == nil {
		fake.getRepositoriesByOwnerReturnsOnCall = make(map[int]struct {
			result1 []*model.Repository
			result2 error
		})
	}
	fake.getRepositoriesByOwnerReturnsOnCall[i] = struct {
		result1 []*model.Repository
		result2 error
	}{result1, result2}
}

func (fake *FakeRepositoryService) GetRepositories() ([]*model.Repository, error) {
	fake.getRepositoriesMutex.Lock()
	ret, specificReturn := fake.getRepositoriesReturnsOnCall[len(fake.getRepositoriesArgsForCall)]
	fake.getRepositoriesArgsForCall = append(fake.getRepositoriesArgsForCall, struct{}{})
	fake.recordInvocation("GetRepositories", []interface{}{})
	fake.getRepositoriesMutex.Unlock()
	if fake.GetRepositoriesStub != nil {
		return fake.GetRepositoriesStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.getRepositoriesReturns.result1, fake.getRepositoriesReturns.result2
}

func (fake *FakeRepositoryService) GetRepositoriesCallCount() int {
	fake.getRepositoriesMutex.RLock()
	defer fake.getRepositoriesMutex.RUnlock()
	return len(fake.getRepositoriesArgsForCall)
}

func (fake *FakeRepositoryService) GetRepositoriesReturns(result1 []*model.Repository, result2 error) {
	fake.GetRepositoriesStub = nil
	fake.getRepositoriesReturns = struct {
		result1 []*model.Repository
		result2 error
	}{result1, result2}
}

func (fake *FakeRepositoryService) GetRepositoriesReturnsOnCall(i int, result1 []*model.Repository, result2 error) {
	fake.GetRepositoriesStub = nil
	if fake.getRepositoriesReturnsOnCall == nil {
		fake.getRepositoriesReturnsOnCall = make(map[int]struct {
			result1 []*model.Repository
			result2 error
		})
	}
	fake.getRepositoriesReturnsOnCall[i] = struct {
		result1 []*model.Repository
		result2 error
	}{result1, result2}
}

func (fake *FakeRepositoryService) UpdateRepository(m *model.Repository) error {
	fake.updateRepositoryMutex.Lock()
	ret, specificReturn := fake.updateRepositoryReturnsOnCall[len(fake.updateRepositoryArgsForCall)]
	fake.updateRepositoryArgsForCall = append(fake.updateRepositoryArgsForCall, struct {
		m *model.Repository
	}{m})
	fake.recordInvocation("UpdateRepository", []interface{}{m})
	fake.updateRepositoryMutex.Unlock()
	if fake.UpdateRepositoryStub != nil {
		return fake.UpdateRepositoryStub(m)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.updateRepositoryReturns.result1
}

func (fake *FakeRepositoryService) UpdateRepositoryCallCount() int {
	fake.updateRepositoryMutex.RLock()
	defer fake.updateRepositoryMutex.RUnlock()
	return len(fake.updateRepositoryArgsForCall)
}

func (fake *FakeRepositoryService) UpdateRepositoryArgsForCall(i int) *model.Repository {
	fake.updateRepositoryMutex.RLock()
	defer fake.updateRepositoryMutex.RUnlock()
	return fake.updateRepositoryArgsForCall[i].m
}

func (fake *FakeRepositoryService) UpdateRepositoryReturns(result1 error) {
	fake.UpdateRepositoryStub = nil
	fake.updateRepositoryReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeRepositoryService) UpdateRepositoryReturnsOnCall(i int, result1 error) {
	fake.UpdateRepositoryStub = nil
	if fake.updateRepositoryReturnsOnCall == nil {
		fake.updateRepositoryReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.updateRepositoryReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeRepositoryService) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.getRepositoryByIDMutex.RLock()
	defer fake.getRepositoryByIDMutex.RUnlock()
	fake.getRepositoriesByOwnerMutex.RLock()
	defer fake.getRepositoriesByOwnerMutex.RUnlock()
	fake.getRepositoriesMutex.RLock()
	defer fake.getRepositoriesMutex.RUnlock()
	fake.updateRepositoryMutex.RLock()
	defer fake.updateRepositoryMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeRepositoryService) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}
