// Code generated by counterfeiter. DO NOT EDIT.
package fakes

import (
	"sync"

	"github.com/dpolansky/grader-ci/pkg/model"
	_ "github.com/mattn/go-sqlite3"
)

type FakeBuildService struct {
	GetBuildByIDStub        func(id int) (*model.BuildStatus, error)
	getBuildByIDMutex       sync.RWMutex
	getBuildByIDArgsForCall []struct {
		id int
	}
	getBuildByIDReturns struct {
		result1 *model.BuildStatus
		result2 error
	}
	getBuildByIDReturnsOnCall map[int]struct {
		result1 *model.BuildStatus
		result2 error
	}
	GetBuildsByRepositoryIDStub        func(id int) ([]*model.BuildStatus, error)
	getBuildsByRepositoryIDMutex       sync.RWMutex
	getBuildsByRepositoryIDArgsForCall []struct {
		id int
	}
	getBuildsByRepositoryIDReturns struct {
		result1 []*model.BuildStatus
		result2 error
	}
	getBuildsByRepositoryIDReturnsOnCall map[int]struct {
		result1 []*model.BuildStatus
		result2 error
	}
	GetBuildsStub        func() ([]*model.BuildStatus, error)
	getBuildsMutex       sync.RWMutex
	getBuildsArgsForCall []struct{}
	getBuildsReturns     struct {
		result1 []*model.BuildStatus
		result2 error
	}
	getBuildsReturnsOnCall map[int]struct {
		result1 []*model.BuildStatus
		result2 error
	}
	UpdateBuildStub        func(m *model.BuildStatus) (*model.BuildStatus, error)
	updateBuildMutex       sync.RWMutex
	updateBuildArgsForCall []struct {
		m *model.BuildStatus
	}
	updateBuildReturns struct {
		result1 *model.BuildStatus
		result2 error
	}
	updateBuildReturnsOnCall map[int]struct {
		result1 *model.BuildStatus
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeBuildService) GetBuildByID(id int) (*model.BuildStatus, error) {
	fake.getBuildByIDMutex.Lock()
	ret, specificReturn := fake.getBuildByIDReturnsOnCall[len(fake.getBuildByIDArgsForCall)]
	fake.getBuildByIDArgsForCall = append(fake.getBuildByIDArgsForCall, struct {
		id int
	}{id})
	fake.recordInvocation("GetBuildByID", []interface{}{id})
	fake.getBuildByIDMutex.Unlock()
	if fake.GetBuildByIDStub != nil {
		return fake.GetBuildByIDStub(id)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.getBuildByIDReturns.result1, fake.getBuildByIDReturns.result2
}

func (fake *FakeBuildService) GetBuildByIDCallCount() int {
	fake.getBuildByIDMutex.RLock()
	defer fake.getBuildByIDMutex.RUnlock()
	return len(fake.getBuildByIDArgsForCall)
}

func (fake *FakeBuildService) GetBuildByIDArgsForCall(i int) int {
	fake.getBuildByIDMutex.RLock()
	defer fake.getBuildByIDMutex.RUnlock()
	return fake.getBuildByIDArgsForCall[i].id
}

func (fake *FakeBuildService) GetBuildByIDReturns(result1 *model.BuildStatus, result2 error) {
	fake.GetBuildByIDStub = nil
	fake.getBuildByIDReturns = struct {
		result1 *model.BuildStatus
		result2 error
	}{result1, result2}
}

func (fake *FakeBuildService) GetBuildByIDReturnsOnCall(i int, result1 *model.BuildStatus, result2 error) {
	fake.GetBuildByIDStub = nil
	if fake.getBuildByIDReturnsOnCall == nil {
		fake.getBuildByIDReturnsOnCall = make(map[int]struct {
			result1 *model.BuildStatus
			result2 error
		})
	}
	fake.getBuildByIDReturnsOnCall[i] = struct {
		result1 *model.BuildStatus
		result2 error
	}{result1, result2}
}

func (fake *FakeBuildService) GetBuildsByRepositoryID(id int) ([]*model.BuildStatus, error) {
	fake.getBuildsByRepositoryIDMutex.Lock()
	ret, specificReturn := fake.getBuildsByRepositoryIDReturnsOnCall[len(fake.getBuildsByRepositoryIDArgsForCall)]
	fake.getBuildsByRepositoryIDArgsForCall = append(fake.getBuildsByRepositoryIDArgsForCall, struct {
		id int
	}{id})
	fake.recordInvocation("GetBuildsByRepositoryID", []interface{}{id})
	fake.getBuildsByRepositoryIDMutex.Unlock()
	if fake.GetBuildsByRepositoryIDStub != nil {
		return fake.GetBuildsByRepositoryIDStub(id)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.getBuildsByRepositoryIDReturns.result1, fake.getBuildsByRepositoryIDReturns.result2
}

func (fake *FakeBuildService) GetBuildsByRepositoryIDCallCount() int {
	fake.getBuildsByRepositoryIDMutex.RLock()
	defer fake.getBuildsByRepositoryIDMutex.RUnlock()
	return len(fake.getBuildsByRepositoryIDArgsForCall)
}

func (fake *FakeBuildService) GetBuildsByRepositoryIDArgsForCall(i int) int {
	fake.getBuildsByRepositoryIDMutex.RLock()
	defer fake.getBuildsByRepositoryIDMutex.RUnlock()
	return fake.getBuildsByRepositoryIDArgsForCall[i].id
}

func (fake *FakeBuildService) GetBuildsByRepositoryIDReturns(result1 []*model.BuildStatus, result2 error) {
	fake.GetBuildsByRepositoryIDStub = nil
	fake.getBuildsByRepositoryIDReturns = struct {
		result1 []*model.BuildStatus
		result2 error
	}{result1, result2}
}

func (fake *FakeBuildService) GetBuildsByRepositoryIDReturnsOnCall(i int, result1 []*model.BuildStatus, result2 error) {
	fake.GetBuildsByRepositoryIDStub = nil
	if fake.getBuildsByRepositoryIDReturnsOnCall == nil {
		fake.getBuildsByRepositoryIDReturnsOnCall = make(map[int]struct {
			result1 []*model.BuildStatus
			result2 error
		})
	}
	fake.getBuildsByRepositoryIDReturnsOnCall[i] = struct {
		result1 []*model.BuildStatus
		result2 error
	}{result1, result2}
}

func (fake *FakeBuildService) GetBuilds() ([]*model.BuildStatus, error) {
	fake.getBuildsMutex.Lock()
	ret, specificReturn := fake.getBuildsReturnsOnCall[len(fake.getBuildsArgsForCall)]
	fake.getBuildsArgsForCall = append(fake.getBuildsArgsForCall, struct{}{})
	fake.recordInvocation("GetBuilds", []interface{}{})
	fake.getBuildsMutex.Unlock()
	if fake.GetBuildsStub != nil {
		return fake.GetBuildsStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.getBuildsReturns.result1, fake.getBuildsReturns.result2
}

func (fake *FakeBuildService) GetBuildsCallCount() int {
	fake.getBuildsMutex.RLock()
	defer fake.getBuildsMutex.RUnlock()
	return len(fake.getBuildsArgsForCall)
}

func (fake *FakeBuildService) GetBuildsReturns(result1 []*model.BuildStatus, result2 error) {
	fake.GetBuildsStub = nil
	fake.getBuildsReturns = struct {
		result1 []*model.BuildStatus
		result2 error
	}{result1, result2}
}

func (fake *FakeBuildService) GetBuildsReturnsOnCall(i int, result1 []*model.BuildStatus, result2 error) {
	fake.GetBuildsStub = nil
	if fake.getBuildsReturnsOnCall == nil {
		fake.getBuildsReturnsOnCall = make(map[int]struct {
			result1 []*model.BuildStatus
			result2 error
		})
	}
	fake.getBuildsReturnsOnCall[i] = struct {
		result1 []*model.BuildStatus
		result2 error
	}{result1, result2}
}

func (fake *FakeBuildService) UpdateBuild(m *model.BuildStatus) (*model.BuildStatus, error) {
	fake.updateBuildMutex.Lock()
	ret, specificReturn := fake.updateBuildReturnsOnCall[len(fake.updateBuildArgsForCall)]
	fake.updateBuildArgsForCall = append(fake.updateBuildArgsForCall, struct {
		m *model.BuildStatus
	}{m})
	fake.recordInvocation("UpdateBuild", []interface{}{m})
	fake.updateBuildMutex.Unlock()
	if fake.UpdateBuildStub != nil {
		return fake.UpdateBuildStub(m)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.updateBuildReturns.result1, fake.updateBuildReturns.result2
}

func (fake *FakeBuildService) UpdateBuildCallCount() int {
	fake.updateBuildMutex.RLock()
	defer fake.updateBuildMutex.RUnlock()
	return len(fake.updateBuildArgsForCall)
}

func (fake *FakeBuildService) UpdateBuildArgsForCall(i int) *model.BuildStatus {
	fake.updateBuildMutex.RLock()
	defer fake.updateBuildMutex.RUnlock()
	return fake.updateBuildArgsForCall[i].m
}

func (fake *FakeBuildService) UpdateBuildReturns(result1 *model.BuildStatus, result2 error) {
	fake.UpdateBuildStub = nil
	fake.updateBuildReturns = struct {
		result1 *model.BuildStatus
		result2 error
	}{result1, result2}
}

func (fake *FakeBuildService) UpdateBuildReturnsOnCall(i int, result1 *model.BuildStatus, result2 error) {
	fake.UpdateBuildStub = nil
	if fake.updateBuildReturnsOnCall == nil {
		fake.updateBuildReturnsOnCall = make(map[int]struct {
			result1 *model.BuildStatus
			result2 error
		})
	}
	fake.updateBuildReturnsOnCall[i] = struct {
		result1 *model.BuildStatus
		result2 error
	}{result1, result2}
}

func (fake *FakeBuildService) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.getBuildByIDMutex.RLock()
	defer fake.getBuildByIDMutex.RUnlock()
	fake.getBuildsByRepositoryIDMutex.RLock()
	defer fake.getBuildsByRepositoryIDMutex.RUnlock()
	fake.getBuildsMutex.RLock()
	defer fake.getBuildsMutex.RUnlock()
	fake.updateBuildMutex.RLock()
	defer fake.updateBuildMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeBuildService) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}
